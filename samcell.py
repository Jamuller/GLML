# ==========================================================================class Cell (object):    # ======================================================================    # DATA MEMBERS    alive = None    row = None    col = None    grid = None    live_neighbors = None    # ======================================================================    # ======================================================================    # INITIALIZER    def __init__ (self, row, col, grid, alive):        self.row = row        self.col = col        self.grid = grid        self.alive = alive    # ======================================================================    # ======================================================================    # COUNT LIVE NEIGHBORS    # Determine how many live neighbors are in the grid.    # FIX ME: Create a method that will have this cell call its grid,    # finding out which of its neighbors -- its immediately adjacent    # cells in the grid -- are alive.  The cell should hold onto its    # result in its 'live_neighbors' data member.    def count_live_neighbors(self):        count = 0        if self.grid.is_alive(( self.row + 1, self.col + 1)):            count += 1        if self.grid.is_alive((self.row - 1, self.col)):            count += 1        if self.grid.is_alive((self.row + 1, self.col - 1)):            count += 1        if self.grid.is_alive((self.row, self.col + 1)):            count += 1        if self.grid.is_alive((self.row - 1, self.col - 1)):            count += 1        if self.grid.is_alive((self.row + 1, self.col)):            count += 1        if self.grid.is_alive((self.row - 1, self.col + 1)):            count += 1        if self.grid.is_alive((self.row, self.col - 1)):            count += 1        self.live_neighbors = count                                                    # ======================================================================    # ======================================================================    # EVOLVE    # Apply the rules and return whether the state changes.    # FIX ME: Create a method that, given the number of live    # neighbors, and given the current aliveness of the cell,    # determine whether the cell should be alive in the next    # generation.  The cell should immediately take on that liveness;    # the method should return whether the cell changed liveness.    def evolve(self):        if self.alive:            if self.live_neighbors == 2 or self.live_neighbors == 3:                return True            else:                self.alive = False                return False        else:            if self.live_neighbors == 3:                self.alive = True                return True            else:                return False                                                                                                    # ======================================================================    # ======================================================================    # STRING    # Generate a string that represents the entire grid of cells.    # FIX ME: Return a string representation of the cell based on its    # liveness.  Provide a plus-sign for a cell that is alive, a    # minus-sign for one that is dead.    def __str__ (self):        if self.alive:            return "+"        else:            return "-"    # ======================================================================# ==========================================================================# END OF Cell CLASS